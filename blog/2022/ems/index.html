<!DOCTYPE html> <html> <head> <meta name="google-site-verification" content="GE78cdBqx5YPEbHjqtohe_p51Ng8oEPXdcaSEIu2dP8"/> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>How to derive an EM algorithm from scratch | Teng Gao</title> <meta name="author" content="Teng Gao"/> <meta name="description" content="From theory to implementation"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚛️</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://teng-gao.github.io/blog/2022/ems/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams",inlineMath:[["$","$"],["\\(","\\)"]]}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <d-front-matter> <script async type="text/json">{
      "title": "How to derive an EM algorithm from scratch",
      "description": "From theory to implementation",
      "published": "November 2, 2022",
      "authors": [
        {
          "author": "Teng Gao",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Havard Medical School",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <body class="fixed-top-nav"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Teng </span>Gao</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Notes<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li id="show-cv" class="nav-item"> <a class="nav-link" target="_blank" href="https://teng-gao.github.io/assets/pdf/Teng_Gao_CV.pdf"> CV </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>How to derive an EM algorithm from scratch</h1> <p>From theory to implementation</p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#the-motivation-behind-em">The motivation behind EM</a></div> <div><a href="#the-general-em-framework">The general EM framework</a></div> <ul> <li><a href="#derivation">Derivation</a></li> <li><a href="#visualization">Visualization</a></li> <li><a href="#proof-of-correctness">Proof of correctness</a></li> </ul> <div><a href="#deriving-an-em-algorithm">Deriving an EM algorithm</a></div> <ul> <li><a href="#general-procedure">General procedure</a></li> <li><a href="#example-derivation">Example derivation</a></li> <li><a href="#implementation">Implementation</a></li> </ul> </nav> </d-contents> <meta name="twitter:card" content="summary"> <meta name="twitter:site" content="@tGaoTeng"> <meta name="twitter:title" content="How to derive an EM algorithm from scratch"> <meta name="twitter:description" content="From theory to implementation"> <meta name="twitter:image" content="https://teng-gao.github.io/assets/img/EM1.png"> <p>Expectation-maximization (EM) is a powerful class of statistical algorithms for performing inference in the presence of latent (unobserved) variables. There are many variations of EM being applied to solve different problems (e.g. Gaussian mixtures, HMMs, LDA, you name it). However, it is often unclear how to derive an EM algorithm, from scratch, for a new problem. In this tutorial, we will first derive and prove the <em>general</em> EM framework, which reveals the fundamental principles that all EM algorithms share. Then, we will use an example (mixture of exponentials) to illustrate how to derive a <em>specific</em> EM algorithm using this general framework for any problem.</p> <h2 id="the-motivation-behind-em">The motivation behind EM</h2> <p>Maximum likelihood estimation (MLE) is a widely used parameter estimation technique in statistical inference. MLE is relatively straightforward to perform in the settings of <em>complete</em> observations. However, in practice, we frequently have to account for unobserved variables/parameters in the model, which we call <strong>latent variables</strong>. In these cases, the likelihood of our (observed) data actually depends on the values of the latent variables.</p> <p>Formally, let $x = {x_1, x_2, \ldots}$ be the set of observed data and $z = {z_1, z_2, \ldots}$ be the (unobserved) latent variables. Let $\theta$ be the parameter that we wish to estimate and assume each $z_i \in \mathcal{Z}$ is discrete. To find the MLE of $\theta$, we need to maximize the log <strong>marginal likelihood</strong> of the data:</p> \[l(\theta) = \log p(x|\theta) = \log \Big(\sum_{z\in\mathcal{Z}^n} p(x, z|\theta) \Big) = \log \Big(\sum_{z\in\mathcal{Z}^n} p(x|z,\theta)p(z|\theta) \Big)\] <p>which is often intractable (since the space of all possible combinations of $z$ can be immense) or has no closed-form solution (since we have a summation inside a log, which makes partial derivatives with respect to $\theta$ difficult).</p> <p>Note that we can always treat the likelihood as a generic objective function and apply different numerical optimization techniques. EM is an iterative algorithm that solves this optimization problem faster by exploiting the probabilistic structure of the data generation process.</p> <h2 id="the-general-em-framework">The general EM framework</h2> <p>Since all EM algorithms are just specific realizations of the general EM algorithm, we will first derive the general EM framework on the most abstract level (also from scratch!).</p> <h3 id="derivation">Derivation</h3> <p>The key idea behind EM is that although there is no easy way to optimize the marginal log-likelihood $l(\theta)=\log p(x|\theta)$ directly, we can construct a <em>lower bound</em> of it that we can easily optimize. Let $q$ be any valid distribution function for $z$,</p> \[\begin{align*} l(\theta) = \log p(x|\theta) &amp;= \log \sum_{z \in \mathcal{Z}^n} p(x,z|\theta) \\ &amp;= \log \sum_{z \in \mathcal{Z}^n} q(z)\frac{ p(x,z|\theta)}{q(z)} \\ &amp;= \log E_{q(z)}\Big[\frac{ p(x,z|\theta)}{q(z)} \Big] \\ &amp;\geq E_{q(z)}\Big[\log \frac{p(x,z|\theta)}{q(z)} \Big] \\ &amp;= E_{q(z)} [\log p(x,z|\theta)] - E_{q(z)}[\log q(z)] \\ &amp;= E_{q(z)} [\log p(x,z|\theta)] + H(q) \\ &amp;\equiv \text{ELBO}(\theta, q) \end{align*}\] <p>In the fourth step we applied Jensen’s inequality (and the fact that log is a concave function). You may recognize that this is exactly the <strong>Evidence Lower Bound (ELBO)</strong>. Here “evidence” refers to the observed data, and it is called the ELBO because it’s a lower bound. Note that the ELBO depends on two things: the unknown parameter $\theta$ and the distribution function for the latent variable $q(z)$. Now, EM arises from the following two insights.</p> <p>First, for a given $q(z)$, finding the $\theta$ that maximizes the ELBO is much easier than optimizing marginal likelihood. Let’s call the first component of this lower bound</p> \[Q(\theta) = E_{q(z)} [\log p(x,z|\theta)] = \sum_{z\in\mathcal{Z}^n} q(z) \log p(x,z|\theta)\] <p>Since the second term $H(q)$ (the entropy of function $q$) does not depend on $\theta$, maximizing $Q(\theta)$ sufficient to maximize the ELBO. Notice that now the log is inside the sum, and taking derivatives with respect to $\theta$ is much easier! For this reason, we can often find <em>analytical</em> solutions for maximizing the ELBO as a function of $\theta$.</p> <p>Second, given a fixed $\theta$, finding the $q(z)$ that maximizes the ELBO is also easy. To see this, let’s rewrite the ELBO in a different form:</p> \[\begin{align*} \text{ELBO}(\theta, q) &amp;= E_{q(z)}\Big[\log \Big( \frac{p(x,z|\theta)}{q(z)} \Big) \Big] \\ &amp;= E_{q(z)}\Big[\log \Big( \frac{p(x,z|\theta)}{p(z|x,\theta)} \frac{p(z|x,\theta)}{q(z)} \Big) \Big] \\ &amp;= E_{q(z)}\Big[\log \Big( \frac{p(z|x,\theta)p(x|\theta)}{p(z|x,\theta)} \frac{p(z|x,\theta)}{q(z)} \Big)\Big] \\ &amp;= E_{q(z)}\Big[\log \Big( p(x|\theta) \frac{p(z|x,\theta)}{q(z)} \Big)\Big] \\ &amp;= E_{q(z)}[\log p(x|\theta)] - E_{q(z)}\Big[\log\Big( \frac{q(z)}{p(z|x,\theta)} \Big)\Big] \\ &amp;= \log p(x|\theta) - \text{KL}(q || p(z|x,\theta)) \end{align*}\] <p>Here we can see that the gap between the ELBO and the marginal log-likelihood is exactly the <strong>Kullback–Leibler (KL)</strong> divergence between $q$ and $p(z|x,\theta)$, a.k.a the posterior of the latent variable conditioned on the observed data and the parameter $\theta$. Since KL between two distributions is non-negative and is only 0 when they are exactly the same, it becomes apparent that the choice of $q(z)$ that maximizes the ELBO is precisely $p(z|x,\theta)$.</p> <p>Combining the above two observations, we arrive at an iterative procedure to obtain ML estimate of $\theta$, which alternates between optimizing the ELBO with respect to $\theta$ while holding $q(z)$ fixed, then with respect to $q(z)$ while holding $\theta$ fixed.</p> <ol> <li>Initialize $\theta = \theta^{(0)}$.</li> <li>(<strong>E-step</strong>) Compute the posterior of the latent variables $p(z | x,\theta^{(t)})$ and use it to compute $Q(\theta)$.</li> <li>(<strong>M-step</strong>) Find new $\theta$ estimate that maximizes $Q(\theta)$; i.e., $\theta^{(t+1)} = \arg \max_\theta Q(\theta)$.</li> </ol> <p>The second step is called the E-step because it involves the computation of $Q$, which is an expectation. The third step is called the M-step because it is maximizing the objective function $Q(\theta)$. Note that $Q$ can be viewed as the same function across time steps but configured with different $\theta^{(t)}$s, so we often write it as $Q(\theta; \theta^{(t)})$, a function of both $\theta$ and $\theta^{(t)}$.</p> <p>The E-step is in some way also a maximization step, because choosing $q(z) = p(z | x,\theta^{(t)})$ maximizes the ELBO at $\theta = \theta^{(t)}$ (in fact, it is exactly equal to $l(\theta^{(t)})$, the log marginal likelihood at $\theta = \theta^{(t)}$). In this way, EM can be viewed as a special case of <a href="https://en.wikipedia.org/wiki/Coordinate_descent" target="_blank" rel="noopener noreferrer">coordinate ascent</a>.</p> <h3 id="visualization">Visualization</h3> <p>Here is a graphical illustration of how the iterative update works:</p> <center> <img src="/assets/img/EM1.png" alt="drawing" style="width:700px;"> </center> <p><strong>Figure 1</strong>. EM parameter update at iteration $t$. Two functions are plotted: the log marginal likelihood $l(\theta)$ and the ELBO computed using $q_t(z)=p(z|x,\theta^{(t)})$. The gap between $l(\theta)$ and the ELBO is the KL divergence between $q_t(z)$ and $p(z|x;\theta)$. In the M-step, we move from point A to point B by optimizing ELBO with respect to $\theta$. In the E-step, we maximize the ELBO at the updated $\theta$ by updating the $q(z)$ function, moving from point B to point C.</p> <h3 id="proof-of-correctness">Proof of correctness</h3> <p>How do we know whether EM is guaranteed to converge? It can be proved that the marginal likelihood monotonically increases with each parameter update. i.e.,</p> \[l(\theta^{(0)}) \leq l(\theta^{(1)}) \leq l(\theta^{(2)}) \leq \cdots\] <p>From the diagram above, we can intuitively see why this is true. The three points that we have marked on the graph respectively represent three key quantities:</p> \[\begin{align*} A&amp;: \text{ELBO}(\theta^{(t)},q_t)=l(\theta^{(t)}) \\ B&amp;: \text{ELBO}(\theta^{(t+1)},q_t) \\ C&amp;: l(\theta^{(t+1)}) \end{align*}\] <p>Intuitively, B is always higher than A, and C is always higher than B in the graph. More formally,</p> \[l(\theta^{(t+1)}) \geq \text{ELBO}(\theta^{(t+1)},q_t) \geq \text{ELBO}(\theta^{(t)},q_t)=l(\theta^{(t)})\] <p>Where the first inequality is because ELBO is always a lower bound of $l$, the second is because we choose the new $\theta$ to be the maximizer of the current ELBO, and the final inequality is that $q_t$ was chosen so that the current ELBO is exactly equal to $l$ at the current $\theta$. Therefore, each time we update $\theta$ (M-step) we attain a higher marginal likelihood.</p> <p>On the other hand, when we update $q(z)$ while keeping $\theta$ fixed (E-step), we choose $q_{t+1}$ such that we make the ELBO exactly equal to $l$ at the current $\theta$. So,</p> \[\text{ELBO}(\theta^{(t)},q_{t+1}) = l(\theta^{(t)}) \geq \text{ELBO}(\theta^{(t)},q_t)\] <p>so each time we update $q(z)$ we make the ELBO a tighter bound of $l$ at the current $\theta$.</p> <p>We can now appreciate that with a few lines of derivations, we have achieved something significant: we have derived and proved a general class of EM algorithms that can be applied to a wide range of statistical models.</p> <h2 id="deriving-an-em-algorithm">Deriving an EM algorithm</h2> <h3 id="general-procedure">General procedure</h3> <p>Based on the framework above, we have the following steps for deriving the EM update rules for specific inference problem. To be more general, let’s use $\Theta$ to denote the collection of parameters in a model.</p> <ol> <li>To derive the E-step (finding the lower bound), write down the conditional posterior $p(z|x,\Theta^{(t)})$ and the $Q(\Theta; \Theta^{(t)})$ function:</li> </ol> \[Q(\Theta; \Theta^{(t)}) = E_{p(z|x,\Theta^{(t)})} [\log p(x,z|\Theta)]\] <ol> <li>To drive the M-step (updating parameters to maximize the lower bound), find an analytical formula for $\Theta$ such that \(\Theta^{(t+1)} = \arg\max_\Theta Q(\Theta; \Theta^{(t)})\)</li> </ol> <p>This gives the parameter update rule.</p> <h3 id="example-derivation">Example derivation</h3> <p>Let’s go over a concrete example to see how EM derivation works in action. Let’s say we are trying to infer the failure rates of light bulbs coming from different manufacturing batches. Let $x_i$ be the observed failure time of lightbulb $i \in {1\ldots n}$, and $z_i \in {1, \ldots, K}$ be the batch that lightbulb $i$ came from (which we do not observe). Let’s model the failure time using an exponential distribution, where the failure rate is different for each batch $k$:</p> \[x_i |z_i = k \overset{ind}{\sim} \text{Expo}(\lambda_k)\] <p>The batch itself is drawn from a categorial distribution:</p> \[z_i \overset{i.i.d.}{\sim} \text{Categorical}(\pmb{\pi})\] <p>To make the problem more challenging, let’s say both $\pmb{\lambda} = (\lambda_1, \lambda_2, \ldots, \lambda_K)$ and $\pmb{\pi} = (\pi_1, \pi_2, \ldots, \pi_K)$ are unknown. Let’s denote the collection of these model parameters as $\Theta = (\pmb{\lambda}, \pmb{\pi})$. Well, how do we figure out the failure rates of different light bulb batches, if the batch labels themselves are unknown? Let’s see how we can derive an EM algorithms that can achieve this.</p> <p>First, let’s derive the E-step.</p> \[\begin{align*} Q(\Theta; \Theta^{(t)}) &amp;= E_{z} [\sum_i \log p(x_i,z_i|\Theta)] \\ &amp;= \sum_i E_{z} [\log p(x_i|z_i,\pmb{\lambda}) p(z_i|\pmb{\pi})] \\ &amp;= \sum_i \{ E_{z} [\log p(x_i|z_i,\pmb{\lambda})] + E_z[ \log p(z_i|\pmb{\pi})] \} \end{align*}\] <p>We can see that the $Q$ function is broken up into two main components, which are respectively:</p> \[\begin{align*} \sum_i E_{z} [\log p(x_i|z_i,\pmb{\lambda})] &amp;= \sum_i \sum_k p(z_i=k|x_i,\Theta^{(t)}) \log p(x_i|z_i=k,\lambda_k) \\ &amp;= \sum_i \sum_k \phi^t_{z_i}(k) (\log \lambda_k - \lambda_k x_i) \end{align*}\] \[\begin{align*} \sum_i E_z[ \log p(z_i|\pmb{\pi})] &amp;= \sum_i \sum_k p(z_i=k|x_i,\Theta^{(t)}) \log \pi_k \\ &amp;= \sum_i \sum_k \phi^t_{z_i}(k) \log \pi_k \end{align*}\] <p>Where we have defined $\phi^t_{z_i}(k) = p(z_i=k|x_i,\Theta^{(t)})$, which is intuitively the membership probability that lightbulb $x_i$ belongs to batch $k$. Note that this quantity does not dependent on $\Theta$ (it only depends on $\Theta^{(t)}$, which is treated as a known constant). Also, $\sum_k \phi^t_{z_i}(k) = 1$ since it is a conditional probability. We can compute it using Bayes’ Rule:</p> \[\begin{align*} \phi^t_{z_i}(k) &amp;= p(z_i=k|x_i,\Theta^{(t)}) \\ &amp;= \frac{p(x_i|z_i=k,\lambda^t_k)p(z_i = k|\pi^t_k)}{\sum_k p(x_i|z_i=k,\lambda^t_k)p(z_i = k|\pi^t_k)} \\ &amp;= \frac{\lambda_k^t \text{exp}(-\lambda_k^t x_i) \pi_k^t}{\sum_k \lambda_k^t \text{exp}(-\lambda_k^t x_i) \pi_k^t} \end{align*}\] <p>All together, we have</p> \[Q^t(\Theta) = \sum_i \sum_k \phi^t_{z_i}(k) (\log \lambda_k - \lambda_k x_i) + \sum_i \sum_k \phi^t_{z_i}(k) \log \pi_k\] <p>which is a function of $\pmb{\lambda},\pmb{\pi}$ and $\pmb{\lambda}^{(t)},\pmb{\pi}^{(t)}$.</p> <p>Now, let’s derive the M-step. Taking partial derivatives with respect to each $\pi_k$ parameter, while adding a Lagrange multiplier $\alpha$ for the constraint $\sum_k \pi_k = 1$, we have:</p> \[\frac{\partial (Q^t + \alpha(1-\sum_k \pi_k))}{\partial \pi_k} = \sum_i \frac{\phi^t_{z_i}(k)}{\pi_k} - \alpha \overset{\Delta}{=} 0 \\ \implies \pi_k = \frac{\sum_i \phi^t_{z_i}(k)}{\alpha}\] <p>Since $\sum_k \pi_k = 1$ and $\phi^t_{z_i}(k) = 1$,</p> \[\begin{align*} \frac{\sum_k \sum_i \phi^t_{z_i}(k)}{\alpha} &amp;= 1 \\ \alpha &amp;= \sum_i \sum_k \phi^t_{z_i}(k) = \sum_i 1 = n \end{align*}\] <p>So this means that the parameter update for $\pi_k$ is</p> \[\pi_k = \frac{\sum_i \phi^t_{z_i}(k)}{n}\] <p>For $\lambda_k$, take partial derivative again:</p> \[\frac{\partial Q^t}{\partial \lambda_k} = \sum_i \phi^t_{z_i}(k) (\lambda_k^{-1}-x_i) \overset{\Delta}{=} 0 \\ \implies \lambda_k = \frac{\sum_i \phi^t_{z_i}(k) }{\sum_i \phi^t_{z_i}(k)x_i }\] <p>Putting the two steps together, we have the following iterative update rules:</p> <ol> <li>Initialize $\pi^{(0)}_k = 1/K$ and $\lambda^{(0)}_k = 1$.</li> <li>(E-step) Compute $\phi^t_{z_i}(k)$ and $Q^t(\Theta)$, where</li> </ol> \[\phi^t_{z_i}(k) = \frac{\lambda_k^t \text{exp}(-\lambda_k^t x_i) \pi_k^t}{\sum_k \lambda_k^t \text{exp}(-\lambda_k^t x_i) \pi_k^t}\] <ol> <li>(M-step) Update parameters</li> </ol> \[\begin{align*} \lambda^{(t+1)}_k &amp;= \frac{\sum_i \phi^t_{z_i}(k) }{\sum_i \phi^t_{z_i}(k)x_i} \\ \pi^{(t+1)}_k &amp;= \frac{\sum_i \phi^t_{z_i}(k)}{n} \end{align*}\] <p>which works for any exponential mixtures. Note that the $Q$ function does not need to be explicitly computed, because we have an analytical solution for maximizing it (which is our M-step).</p> <h3 id="implementation">Implementation</h3> <p>Here is an implementation of the EM algorithm we just derived (in R).</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">dplyr</span><span class="p">)</span><span class="w">

</span><span class="n">get_phi_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">lambda_t</span><span class="p">,</span><span class="w"> </span><span class="n">pi_t</span><span class="p">,</span><span class="w"> </span><span class="n">x_i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">k</span><span class="p">){</span><span class="w">
        </span><span class="n">lambda_t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">lambda_t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x_i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pi_t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w">
    </span><span class="p">})</span><span class="w">
    </span><span class="n">phi_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="nf">sum</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="w">
    </span><span class="nf">return</span><span class="p">(</span><span class="n">phi_k</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">update_lambda_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">phi_k</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">lambda_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">phi_k</span><span class="p">)</span><span class="o">/</span><span class="nf">sum</span><span class="p">(</span><span class="n">phi_k</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="w">
    </span><span class="nf">return</span><span class="p">(</span><span class="n">lambda_k</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">update_pi_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">phi_k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">pi_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">phi_k</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="w">
    </span><span class="nf">return</span><span class="p">(</span><span class="n">pi_k</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">

</span><span class="n">run_em</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">max_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    
    </span><span class="c1"># initialization</span><span class="w">
    </span><span class="nb">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">()</span><span class="w">
    </span><span class="n">lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">list</span><span class="p">()</span><span class="w">
    </span><span class="nb">pi</span><span class="p">[[</span><span class="m">1</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="o">/</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w">
    </span><span class="n">lambda</span><span class="p">[[</span><span class="m">1</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="n">K</span><span class="w">
    
    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="p">(</span><span class="n">max_iter</span><span class="m">-1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
        
        </span><span class="c1"># E-step</span><span class="w">
        </span><span class="n">phi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="n">get_phi_k</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">lambda</span><span class="p">[[</span><span class="n">t</span><span class="p">]],</span><span class="w"> </span><span class="nb">pi</span><span class="p">[[</span><span class="n">t</span><span class="p">]],</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w">
            </span><span class="p">})</span><span class="w">
        </span><span class="p">})</span><span class="w">
        
        </span><span class="c1"># M-step</span><span class="w">
        </span><span class="n">lambda</span><span class="p">[[</span><span class="n">t</span><span class="m">+1</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">update_lambda_k</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">phi</span><span class="p">[[</span><span class="n">k</span><span class="p">]],</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
        </span><span class="p">})</span><span class="w">
        
        </span><span class="nb">pi</span><span class="p">[[</span><span class="n">t</span><span class="m">+1</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">update_pi_k</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">phi</span><span class="p">[[</span><span class="n">k</span><span class="p">]])</span><span class="w">
        </span><span class="p">})</span><span class="w">
                             
    </span><span class="p">}</span><span class="w">
                             
    </span><span class="nf">return</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lambda</span><span class="p">,</span><span class="w"> </span><span class="nb">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">pi</span><span class="p">))</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <p>Let’s simulate some data, with 3 batches each with different failure rates.</p> <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">K</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="w">
</span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1000</span><span class="w">
</span><span class="n">set.seed</span><span class="p">(</span><span class="m">2</span><span class="p">)</span><span class="w">

</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="w">
    </span><span class="n">rgamma</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">500</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">rate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">),</span><span class="w">
    </span><span class="n">rgamma</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">300</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">rate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="p">),</span><span class="w">
    </span><span class="n">rgamma</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">200</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">rate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="p">)</span><span class="w">
</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">sort</span><span class="w">

</span><span class="n">n_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="w">
</span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run_em</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">max_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_iter</span><span class="p">)</span><span class="w">
</span></code></pre></div></div> <center> <img src="/assets/img/EM2.png" alt="drawing" style="width:700px;"> </center> <p><strong>Figure 2</strong>. <strong>A</strong>, Distribution of the simulated data. <strong>B</strong>, log-model likelihood across iterations. <strong>C</strong> and <strong>D</strong>, parameter estimates at each iteration. Red triangles mark the true parameter values.</p> <p>We see that the algorithm converges after 50 iterations or so, with monotonically improving model fit. Even though we can’t spot any obvious batch effects in the distribution of the data, the failure rate and prevalence of each batch estimated by EM are pretty much spot-on!</p> <h2 id="acknowledgements">Acknowledgements</h2> <p>Thanks to Hirak Sarkar for providing helpful feedback. The illustration in Figure 1 was largely inspired by this <a href="https://mbernste.github.io/posts/em/" target="_blank" rel="noopener noreferrer">post</a>.</p> <h2 id="references-and-further-readings">References and further readings</h2> <ol> <li> <p><a href="https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm</a></p> </li> <li> <p><a href="https://mbernste.github.io/posts/em/" target="_blank" rel="noopener noreferrer">https://mbernste.github.io/posts/em/</a></p> </li> <li> <p><a href="https://hiraksarkar.github.io/posts/2021/06/theory-of-vae/" target="_blank" rel="noopener noreferrer">https://hiraksarkar.github.io/posts/2021/06/theory-of-vae/</a></p> </li> <li> <p><a href="http://www.cs.cmu.edu/~awm/10701/assignments/EM.pdf" target="_blank" rel="noopener noreferrer">http://www.cs.cmu.edu/~awm/10701/assignments/EM.pdf</a></p> </li> </ol> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Last updated: November 22, 2024. </div> </footer> <d-bibliography src="/assets/bibliography/"></d-bibliography> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>